/**
 * Simple client-side search functionality for Typstify sites
 * Uses the search-index.json file generated by the Tantivy search engine
 */

class TypstifySearch {
    constructor() {
        this.searchIndex = null;
        this.isLoaded = false;
        this.searchInput = null;
        this.searchResults = null;
        this.searchContainer = null;
    }

    /**
     * Initialize the search functionality
     */
    async init() {
        // Find search elements
        this.searchInput = document.querySelector('#search-input');
        this.searchResults = document.querySelector('#search-results');
        this.searchContainer = document.querySelector('#search-container');

        if (!this.searchInput || !this.searchResults) {
            console.warn('Search elements not found');
            return;
        }

        // Load search index
        try {
            await this.loadSearchIndex();
        } catch (error) {
            console.error('Failed to load search index:', error);
            return;
        }

        // Set up event listeners
        this.setupEventListeners();
        
        console.log('Typstify search initialized successfully');
    }

    /**
     * Load the search index from the JSON file
     */
    async loadSearchIndex() {
        if (this.isLoaded) return;

        const response = await fetch('/search-index.json');
        if (!response.ok) {
            throw new Error(`Failed to load search index: ${response.status}`);
        }

        this.searchIndex = await response.json();
        this.isLoaded = true;
        console.log(`Loaded search index with ${this.searchIndex.length} entries`);
    }

    /**
     * Set up event listeners for search functionality
     */
    setupEventListeners() {
        let searchTimeout;

        // Search on input
        this.searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const query = e.target.value.trim();
                this.performSearch(query);
            }, 300);
        });

        // Handle keyboard navigation
        this.searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideResults();
                this.searchInput.blur();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                this.focusFirstResult();
            }
        });

        // Hide results when clicking outside
        document.addEventListener('click', (e) => {
            if (!this.searchContainer.contains(e.target)) {
                this.hideResults();
            }
        });

        // Show results when focusing on search input
        this.searchInput.addEventListener('focus', () => {
            if (this.searchInput.value.trim()) {
                this.showResults();
            }
        });
    }

    /**
     * Perform search and display results
     */
    performSearch(query) {
        if (!this.isLoaded || !this.searchIndex) {
            console.warn('Search index not loaded');
            return;
        }

        if (query.length < 2) {
            this.hideResults();
            return;
        }

        const results = this.searchInIndex(query);
        this.displayResults(results, query);
    }

    /**
     * Search through the loaded index
     */
    searchInIndex(query) {
        const queryLower = query.toLowerCase();
        const queryWords = queryLower.split(/\s+/).filter(word => word.length > 1);
        
        if (queryWords.length === 0) {
            return [];
        }

        const results = [];

        for (const entry of this.searchIndex) {
            const score = this.calculateScore(entry, queryWords);
            if (score > 0) {
                results.push({
                    entry,
                    score,
                    snippet: this.generateSnippet(entry, queryWords)
                });
            }
        }

        // Sort by score (descending) and limit results
        results.sort((a, b) => b.score - a.score);
        return results.slice(0, 10);
    }

    /**
     * Calculate relevance score for an entry
     */
    calculateScore(entry, queryWords) {
        let score = 0;
        const titleLower = entry.title.toLowerCase();
        const descriptionLower = entry.description.toLowerCase();
        const contentLower = entry.content.toLowerCase();
        const tagsLower = entry.tags.map(tag => tag.toLowerCase());

        for (const word of queryWords) {
            // Title matches (highest weight)
            if (titleLower.includes(word)) {
                score += titleLower === word ? 10 : 5;
            }

            // Description matches
            if (descriptionLower.includes(word)) {
                score += 3;
            }

            // Tag matches
            for (const tag of tagsLower) {
                if (tag.includes(word)) {
                    score += tag === word ? 4 : 2;
                }
            }

            // Content matches (lower weight)
            const contentMatches = (contentLower.match(new RegExp(word, 'g')) || []).length;
            score += Math.min(contentMatches * 0.1, 2);
        }

        return score;
    }

    /**
     * Generate a snippet with highlighted search terms
     */
    generateSnippet(entry, queryWords) {
        let text = entry.description || entry.content;
        if (!text) return '';

        // Find the best snippet around query words
        const textLower = text.toLowerCase();
        let bestStart = 0;
        let bestScore = 0;

        // Look for the position with most query words
        for (let i = 0; i < text.length - 150; i += 50) {
            const snippet = textLower.slice(i, i + 150);
            let score = 0;
            for (const word of queryWords) {
                score += (snippet.match(new RegExp(word, 'g')) || []).length;
            }
            if (score > bestScore) {
                bestScore = score;
                bestStart = i;
            }
        }

        let snippet = text.slice(bestStart, bestStart + 150);
        if (bestStart > 0) snippet = '...' + snippet;
        if (bestStart + 150 < text.length) snippet += '...';

        // Highlight query words
        for (const word of queryWords) {
            const regex = new RegExp(`(${this.escapeRegex(word)})`, 'gi');
            snippet = snippet.replace(regex, '<mark>$1</mark>');
        }

        return snippet;
    }

    /**
     * Escape special regex characters
     */
    escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Display search results
     */
    displayResults(results, query) {
        if (results.length === 0) {
            this.searchResults.innerHTML = `
                <div class="search-no-results">
                    <p>No results found for "${query}"</p>
                </div>
            `;
        } else {
            const resultsHtml = results.map(result => this.renderResult(result)).join('');
            this.searchResults.innerHTML = resultsHtml;
        }

        this.showResults();
    }

    /**
     * Render a single search result
     */
    renderResult(result) {
        const { entry, snippet } = result;
        const tagsHtml = entry.tags.length > 0 
            ? `<div class="search-tags">${entry.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`
            : '';

        return `
            <div class="search-result">
                <h3><a href="${entry.url}">${entry.title}</a></h3>
                ${snippet ? `<p class="search-snippet">${snippet}</p>` : ''}
                ${tagsHtml}
                ${entry.category ? `<div class="search-category">${entry.category}</div>` : ''}
            </div>
        `;
    }

    /**
     * Show search results
     */
    showResults() {
        this.searchResults.style.display = 'block';
    }

    /**
     * Hide search results
     */
    hideResults() {
        this.searchResults.style.display = 'none';
    }

    /**
     * Focus on the first search result
     */
    focusFirstResult() {
        const firstResult = this.searchResults.querySelector('a');
        if (firstResult) {
            firstResult.focus();
        }
    }
}

// Initialize search when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
    const search = new TypstifySearch();
    await search.init();
    
    // Make it globally available for debugging
    window.typstifySearch = search;
});
